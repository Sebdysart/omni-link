# omni-link v0.4 Bulletproof Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Wire the disk cache for warm-session speed, fix API bridge detection against real Swift codebases, deduplicate cross-repo evolution suggestions, eliminate Hono false-positive benchmark alerts, and commit the outstanding plan doc.

**Architecture:** Four engine changes + one git op. Each change is independently testable. No public API changes. `scanRepo()` gains an optional `CacheManager` parameter (backward compatible). `api-extractor.ts` gains `extractSwiftApiCallSites()`. `upgrade-proposer.ts` gains `deduplicateSuggestions()`. `competitive-benchmarker.ts` gains Hono/Fastify framework awareness. All changes are TDD: failing test first.

**Tech Stack:** TypeScript, Vitest, tree-sitter, Node.js fs/child_process, git.

---

## Pre-flight

Before any task, verify the baseline:

```bash
cd /Users/sebastiandysart/.claude/plugins/cache/omni-link-marketplace/omni-link/0.1.0
npm test 2>&1 | tail -5
# Expected: Test Files 30 passed (30), Tests 348 passed (348)
```

---

## Task 1: Wire the Disk Manifest Cache

**Goal:** On warm sessions (same HEAD SHA), `scanRepo()` returns a cached manifest in microseconds instead of re-parsing thousands of files.

**Files:**
- Modify: `engine/scanner/index.ts` (add optional `manifestCache` param)
- Modify: `engine/index.ts` (create CacheManager from config, pass to scanRepo)
- Test: `tests/scanner/index.test.ts` (add cache hit/miss cases)

**Root cause of slow scans:** `CacheManager` in `engine/context/cache-manager.ts` is fully implemented with SHA-keyed manifest storage but is never called. Cold scans take 18–20s. With cache, warm scans should be <100ms.

**Strategy:** `scanRepo()` already runs `extractGitState()` which calls `git rev-parse HEAD`. We call it *before* the main scan loop to get headSha for the cache lookup. If hit, return early. If miss, scan normally, then store at end.

### Step 1: Write the failing tests

Add to `tests/scanner/index.test.ts` (after existing tests):

```typescript
import { CacheManager } from '../../engine/context/cache-manager.js';
import * as os from 'node:os';
import * as path from 'node:path';
import * as fs from 'node:fs';

describe('scanRepo — manifest cache integration', () => {
  it('returns cached manifest on cache hit (same headSha)', () => {
    // Use the existing fixture repo (repoPath is already set up in this test file)
    // This test verifies cache hit: second scan with same headSha is instant
    const cacheDir = path.join(os.tmpdir(), `omni-link-test-cache-${Date.now()}`);
    const cache = new CacheManager(cacheDir);

    // First scan — cold
    const config = { name: 'test-repo', path: repoPath, language: 'typescript', role: 'backend' };
    const manifest1 = scanRepo(config, new Map(), cache);

    // Second scan with same cache — should hit
    const manifest2 = scanRepo(config, new Map(), cache);

    // Both manifests must be structurally identical
    expect(manifest2.repoId).toBe(manifest1.repoId);
    expect(manifest2.gitState.headSha).toBe(manifest1.gitState.headSha);
    expect(manifest2.apiSurface.exports.length).toBe(manifest1.apiSurface.exports.length);

    fs.rmSync(cacheDir, { recursive: true, force: true });
  });

  it('skips cache when no CacheManager provided', () => {
    // Verifies backward compat: no third arg = same behavior as before
    const config = { name: 'test-repo', path: repoPath, language: 'typescript', role: 'backend' };
    const manifest = scanRepo(config, new Map());
    expect(manifest.repoId).toBe('test-repo');
  });

  it('stores and retrieves manifest keyed by headSha', () => {
    const cacheDir = path.join(os.tmpdir(), `omni-link-test-cache2-${Date.now()}`);
    const cache = new CacheManager(cacheDir);

    const config = { name: 'cache-test', path: repoPath, language: 'typescript', role: 'backend' };
    const manifest = scanRepo(config, new Map(), cache);

    // Verify it was stored: retrieve directly from cache manager
    const stored = cache.getCachedManifest('cache-test', manifest.gitState.headSha);
    expect(stored).not.toBeNull();
    expect(stored!.repoId).toBe(manifest.repoId);

    fs.rmSync(cacheDir, { recursive: true, force: true });
  });
});
```

### Step 2: Run to verify failure

```bash
npm test tests/scanner/index.test.ts 2>&1 | grep -E "FAIL|Error|Expected"
# Expected: TypeError — scanRepo does not accept 3rd argument (manifestCache)
```

### Step 3: Implement — modify `engine/scanner/index.ts`

At the top of the file, add import:
```typescript
import type { CacheManager } from '../context/cache-manager.js';
```

Change the `scanRepo` signature from:
```typescript
export function scanRepo(config: RepoConfig, fileCache?: FileCache): RepoManifest {
```
to:
```typescript
export function scanRepo(config: RepoConfig, fileCache?: FileCache, manifestCache?: CacheManager): RepoManifest {
```

After `const { name, path: repoPath, language } = config;`, add manifest cache early-exit:
```typescript
  // ── Manifest cache check ──────────────────────────────────────────────────
  if (manifestCache) {
    const headSha = gitExec(repoPath, 'rev-parse HEAD');
    if (headSha) {
      const cached = manifestCache.getCachedManifest(name, headSha);
      if (cached) return cached;
    }
  }
  // ─────────────────────────────────────────────────────────────────────────
```

At the very end of `scanRepo()`, just before `return manifest;`, add:
```typescript
  // Store in manifest cache for next session
  if (manifestCache && manifest.gitState.headSha) {
    manifestCache.setCachedManifest(name, manifest.gitState.headSha, manifest);
  }
```

### Step 4: Implement — modify `engine/index.ts`

Add import at top:
```typescript
import { CacheManager } from './context/cache-manager.js';
```

In every function that builds manifests (`scan`, `impact`, `impactFromUncommitted`, `health`, `evolve`, `qualityCheck`), add after `const fileCache: FileCache = new Map();`:
```typescript
  const manifestCache: CacheManager | undefined = config.cache?.directory
    ? new CacheManager(config.cache.directory)
    : undefined;
```

Change every `scanRepo(repo, fileCache)` call to:
```typescript
scanRepo(repo, fileCache, manifestCache)
```

There are 6 such calls (one per exported function). Change all of them.

Also wire cache pruning: in the `scan()` function (the primary entry point), after creating `manifestCache`, add:
```typescript
  if (manifestCache && config.cache?.maxAgeDays) {
    manifestCache.pruneOld(config.cache.maxAgeDays);
  }
```

### Step 5: Run tests to verify pass

```bash
npm test tests/scanner/index.test.ts 2>&1 | tail -10
# Expected: all scanner tests pass including 3 new cache tests
npm test 2>&1 | tail -5
# Expected: Test Files 30 passed, Tests 351 passed (348 + 3 new)
```

### Step 6: Commit

```bash
git add engine/scanner/index.ts engine/index.ts tests/scanner/index.test.ts
git commit -m "feat(cache): wire CacheManager into scanRepo() for warm-session speed

Cold scan: unchanged. Warm scan (same HEAD SHA): returns cached manifest
instantly. CacheManager.pruneOld() called at scan start to enforce maxAgeDays.
All 6 engine pipeline functions wire the manifest cache from config.cache.directory."
```

---

## Task 2: Fix API Bridge Detection for Real Swift Codebases

**Goal:** Detect iOS→backend API bridges by extracting URL call sites and tRPC procedure references from Swift source files.

**Root cause of 0 bridges:** `findConsumerReferences()` in `api-contract-map.ts` searches `consumer.apiSurface.exports` for URL path strings. But `extractSwiftExports()` only extracts Swift class/function *declarations* — not the URL strings embedded inside function bodies. iOS service files contain calls like `URL(string: "\(baseURL)/api/users")` and `TRPCClient.shared.mutation("post.create", ...)`, which never appear in the exports array.

**Fix:** Add `extractSwiftApiCallSites()` to `api-extractor.ts` — a regex scanner that finds URL paths and tRPC procedure name strings in Swift source, returned as ExportDef entries. In `scanRepo()`, include call sites in `allExports` for Swift files.

**Files:**
- Modify: `engine/scanner/api-extractor.ts` (add `extractSwiftApiCallSites`)
- Modify: `engine/scanner/index.ts` (call it for Swift files)
- Test: `tests/scanner/api-extractor.test.ts` (new describe block)
- Test: `tests/grapher/api-contract-map.test.ts` (verify bridge detection with call-site exports)

### Step 1: Write failing tests

Add to `tests/scanner/api-extractor.test.ts` (find via `ls tests/scanner/`):

```typescript
import { extractSwiftApiCallSites } from '../../engine/scanner/api-extractor.js';

describe('extractSwiftApiCallSites', () => {
  it('extracts URL path strings from Swift source', () => {
    const source = `
import Foundation
class UserService {
    func fetchUsers() async throws -> [User] {
        let url = URL(string: "\\(baseURL)/api/users")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode([User].self, from: data)
    }
}`;
    const results = extractSwiftApiCallSites(source, 'Services/UserService.swift');
    const urlEntry = results.find(r => r.signature.includes('/api/users'));
    expect(urlEntry).toBeDefined();
    expect(urlEntry!.file).toBe('Services/UserService.swift');
  });

  it('extracts tRPC procedure names from Swift source', () => {
    const source = `
class PostService {
    func createPost(body: CreatePostBody) async throws -> Post {
        return try await trpcClient.mutation("post.create", body: body)
    }
}`;
    const results = extractSwiftApiCallSites(source, 'Services/PostService.swift');
    const procEntry = results.find(r => r.signature.includes('post.create'));
    expect(procEntry).toBeDefined();
  });

  it('returns empty array for Swift source with no API calls', () => {
    const source = `
struct User: Codable {
    let id: String
    let name: String
}`;
    const results = extractSwiftApiCallSites(source, 'Models/User.swift');
    expect(results).toEqual([]);
  });

  it('does not extract non-API string literals', () => {
    const source = `
let greeting = "Hello world"
let message = "error occurred"`;
    const results = extractSwiftApiCallSites(source, 'test.swift');
    expect(results).toHaveLength(0);
  });
});
```

Also add to `tests/grapher/api-contract-map.test.ts`:

```typescript
  it('detects bridges when iOS consumer exports come from call-site extraction', () => {
    // Simulates what scanRepo produces after extractSwiftApiCallSites runs:
    // exports contain URL paths as their signature, which mapApiContracts can match.
    const backend = makeManifest({
      repoId: 'backend',
      apiSurface: {
        routes: [
          {
            method: 'GET',
            path: '/api/posts',
            handler: 'getPosts',
            file: 'src/routes/posts.ts',
            line: 5,
          },
        ],
        procedures: [],
        exports: [],
      },
    });

    const ios = makeManifest({
      repoId: 'ios-app',
      language: 'swift',
      apiSurface: {
        routes: [],
        procedures: [],
        // These are what extractSwiftApiCallSites produces:
        exports: [
          {
            name: '/api/posts',
            kind: 'constant',
            signature: '/api/posts',
            file: 'Services/PostService.swift',
            line: 8,
          },
        ],
      },
    });

    const bridges = mapApiContracts([backend, ios]);
    expect(bridges.length).toBeGreaterThan(0);
    const bridge = bridges.find(b => b.provider.route === 'GET /api/posts');
    expect(bridge).toBeDefined();
    expect(bridge!.consumer.repo).toBe('ios-app');
  });
```

### Step 2: Run to verify failure

```bash
npm test tests/scanner/api-extractor.test.ts 2>&1 | grep -E "FAIL|SyntaxError|not a function"
# Expected: "extractSwiftApiCallSites is not a function"
```

### Step 3: Implement `extractSwiftApiCallSites` in `engine/scanner/api-extractor.ts`

Add after `extractSwiftExports()`:

```typescript
/**
 * Regex-scan Swift source for outbound API call sites:
 * - URL path strings like "/api/users", "/v1/posts"
 * - tRPC procedure name strings like "user.create", "post.getAll"
 *
 * Returns ExportDef entries whose `signature` and `name` contain the
 * URL path or procedure name, so mapApiContracts() can detect iOS→backend
 * bridges via findConsumerReferences() signature matching.
 */
export function extractSwiftApiCallSites(source: string, file: string): ExportDef[] {
  const results: ExportDef[] = [];
  const lines = source.split('\n');

  // URL path pattern: string literals starting with /api/, /v1/, /v2/, /trpc/, etc.
  // Also matches paths starting with just "/" followed by a word (common API prefix)
  const urlPathPattern = /"(\/(?:api|v\d+|trpc)\/[^"]*|\/[a-z][a-z0-9/_-]{2,}[^"\\]*)"/g;

  // tRPC procedure pattern: "namespace.procedureName" — dotted lowercase identifiers
  // Matches things like "user.create", "post.getAll", "auth.login"
  const trpcProcPattern = /"([a-z][a-zA-Z0-9]*\.[a-z][a-zA-Z0-9]*)"/g;

  // Track seen values to avoid duplicate entries (same path appears multiple times)
  const seen = new Set<string>();

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // URL paths
    urlPathPattern.lastIndex = 0;
    let match: RegExpExecArray | null;
    while ((match = urlPathPattern.exec(line)) !== null) {
      const value = match[1];
      const key = `url:${value}:${file}`;
      if (!seen.has(key)) {
        seen.add(key);
        results.push({
          name: value,
          kind: 'constant',
          signature: value,
          file,
          line: i + 1,
        });
      }
    }

    // tRPC procedure names
    trpcProcPattern.lastIndex = 0;
    while ((match = trpcProcPattern.exec(line)) !== null) {
      const value = match[1];
      const key = `proc:${value}:${file}`;
      if (!seen.has(key)) {
        seen.add(key);
        results.push({
          name: value,
          kind: 'constant',
          signature: value,
          file,
          line: i + 1,
        });
      }
    }
  }

  return results;
}
```

### Step 4: Wire into `engine/scanner/index.ts`

Add import at top of the file:
```typescript
import { extractExports, extractRoutes, extractProcedures, extractSwiftApiCallSites } from './api-extractor.js';
```

Inside the `for (const filePath of filePaths)` loop, after the block that assigns `exports`, add call-site extraction for Swift. Find the line `allExports.push(...exports);` and change to:

```typescript
    allExports.push(...exports);

    // For Swift consumer files, also extract outbound API call sites (URL strings,
    // tRPC procedure names) so the grapher can detect iOS→backend bridges.
    if (lang === 'swift') {
      const callSites = extractSwiftApiCallSites(source, relPath);
      allExports.push(...callSites);
    }
```

### Step 5: Run tests to verify pass

```bash
npm test tests/scanner/api-extractor.test.ts tests/grapher/api-contract-map.test.ts 2>&1 | tail -10
# Expected: all tests pass including new call-site and bridge tests
npm test 2>&1 | tail -5
# Expected: all tests pass (count increases by 5 new tests)
```

### Step 6: Commit

```bash
git add engine/scanner/api-extractor.ts engine/scanner/index.ts \
  tests/scanner/api-extractor.test.ts tests/grapher/api-contract-map.test.ts
git commit -m "feat(bridges): detect iOS→backend API bridges via Swift call-site extraction

extractSwiftApiCallSites() regex-scans Swift source for URL path strings
(/api/..., /v1/...) and tRPC procedure names (namespace.proc) and emits
them as ExportDef entries. scanRepo() includes these in allExports for Swift
files. mapApiContracts() findConsumerReferences() can then match them against
backend routes/procedures, enabling real cross-repo bridge detection."
```

---

## Task 3: Deduplicate Cross-Repo Evolution Suggestions

**Goal:** When the same best practice is missing in multiple repos (e.g., CORS in both backend and iOS), produce ONE merged suggestion with `affectedRepos: ['hustlexp-ai-backend', 'hustlexp-ios']` instead of two identical suggestions.

**Root cause:** `proposeUpgrades()` in `upgrade-proposer.ts` generates one `EvolutionSuggestion` per finding. When benchmarker detects the same gap across N repos, N identical suggestions fill the top-5 slots, crowding out genuine gaps with real `file:line` evidence.

**Files:**
- Modify: `engine/evolution/upgrade-proposer.ts` (add `deduplicateSuggestions()`)
- Test: `tests/evolution/upgrade-proposer.test.ts` (add dedup test)

**Dedup key:** `${category}:${title-without-" in <repo>"-suffix}`. Titles follow the pattern "Implement CORS configuration in hustlexp-ai-backend" → key is `"security:Implement CORS configuration"`. Cross-repo duplicates are merged: `affectedRepos` union, `evidence` concatenated. When merged, the repo-specific suffix is removed from the title.

### Step 1: Write failing test

Add to `tests/evolution/upgrade-proposer.test.ts`:

```typescript
  it('deduplicates same-practice suggestions across repos, merging affectedRepos', () => {
    // Two benchmark findings for the same practice in different repos
    const bottlenecks: BottleneckFinding[] = [
      makeBottleneck({
        kind: 'unbounded-query',
        description: '[Best Practice] CORS configuration: Configure CORS headers.',
        repo: 'backend',
        severity: 'high',
      }),
      makeBottleneck({
        kind: 'unbounded-query',
        description: '[Best Practice] CORS configuration: Configure CORS headers.',
        repo: 'ios-app',
        severity: 'high',
      }),
    ];

    const suggestions = proposeUpgrades([], bottlenecks, [makeManifest('backend'), makeManifest('ios-app')]);

    // Should be ONE merged CORS suggestion, not two
    const corsSuggestions = suggestions.filter(s => s.title.toLowerCase().includes('cors'));
    expect(corsSuggestions).toHaveLength(1);
    expect(corsSuggestions[0].affectedRepos).toContain('backend');
    expect(corsSuggestions[0].affectedRepos).toContain('ios-app');
    expect(corsSuggestions[0].affectedRepos.length).toBe(2);
    // Title should not have a repo-specific suffix when multi-repo
    expect(corsSuggestions[0].title).not.toContain(' in backend');
    expect(corsSuggestions[0].title).not.toContain(' in ios-app');
  });
```

### Step 2: Run to verify failure

```bash
npm test tests/evolution/upgrade-proposer.test.ts 2>&1 | grep -E "FAIL|Expected"
# Expected: "Expected 1, received 2" (two CORS suggestions instead of one)
```

### Step 3: Implement in `engine/evolution/upgrade-proposer.ts`

Add the dedup function after `sortSuggestions()`:

```typescript
/**
 * Deduplicate suggestions that represent the same best practice across multiple repos.
 *
 * Dedup key: `${category}:${title-without-" in <repo>"-suffix}`.
 * Merges: affectedRepos (union), evidence (concat).
 * When multiple repos are merged, strips the " in <repo>" suffix from the title.
 */
function deduplicateSuggestions(suggestions: EvolutionSuggestion[]): EvolutionSuggestion[] {
  const deduped = new Map<string, EvolutionSuggestion>();

  for (const s of suggestions) {
    // Build dedup key: strip " in <repoName>" suffix (one word, no spaces)
    const titleBase = s.title.replace(/ in \S+$/, '').trim();
    const key = `${s.category}:${titleBase}`;

    const existing = deduped.get(key);
    if (!existing) {
      // Clone to avoid mutating original
      deduped.set(key, {
        ...s,
        affectedRepos: [...s.affectedRepos],
        evidence: [...s.evidence],
      });
    } else {
      // Merge repos and evidence
      for (const repo of s.affectedRepos) {
        if (!existing.affectedRepos.includes(repo)) {
          existing.affectedRepos.push(repo);
        }
      }
      existing.evidence.push(...s.evidence);
    }
  }

  // Strip " in <repo>" suffix from titles for merged (multi-repo) suggestions
  const result = [...deduped.values()];
  for (const s of result) {
    if (s.affectedRepos.length > 1) {
      s.title = s.title.replace(/ in \S+$/, '').trim();
    }
  }

  return result;
}
```

In `proposeUpgrades()`, change the return statement:
```typescript
  // Before:
  return sortSuggestions(suggestions);

  // After:
  return deduplicateSuggestions(sortSuggestions(suggestions));
```

### Step 4: Run tests to verify pass

```bash
npm test tests/evolution/upgrade-proposer.test.ts 2>&1 | tail -10
# Expected: all 9 tests pass (8 existing + 1 new)
npm test 2>&1 | tail -5
# Expected: all tests pass
```

### Step 5: Commit

```bash
git add engine/evolution/upgrade-proposer.ts tests/evolution/upgrade-proposer.test.ts
git commit -m "feat(evolution): deduplicate cross-repo suggestions, merge affectedRepos

Same best practice missing in N repos → ONE suggestion with affectedRepos=[all N].
Title 'Implement CORS configuration in backend' + 'Implement CORS configuration
in ios-app' → 'Implement CORS configuration' with affectedRepos: ['backend','ios-app'].
Frees top-5 slots for genuinely distinct suggestions with real file:line evidence."
```

---

## Task 4: Framework-Aware Benchmarks (Hono/Fastify + Server-Only Guards)

**Goal:** Eliminate false-positive security alerts for:
1. **Hono projects** — Hono provides CORS/security-headers built-in via `hono/cors` and `hono/secure-headers`; flagging them as 'missing' is incorrect.
2. **Non-server repos** — iOS apps and frontend-only repos should not receive server-specific alerts (rate limiting, CORS) if they have no routes AND no procedures.

**Files:**
- Modify: `engine/evolution/competitive-benchmarker.ts`
- Test: `tests/evolution/competitive-benchmarker.test.ts`

### Step 1: Write failing tests

Add to `tests/evolution/competitive-benchmarker.test.ts`:

```typescript
import { benchmarkAgainstBestPractices } from '../../engine/evolution/competitive-benchmarker.js';
// ... (existing imports and makeManifest helper)

describe('framework-aware benchmarks', () => {
  it('marks CORS as present for Hono projects (cors() is built-in to hono package)', () => {
    const manifest = makeManifest({
      repoId: 'hono-backend',
      apiSurface: {
        routes: [{ method: 'GET', path: '/api/users', handler: 'getUsers', file: 'src/index.ts', line: 5 }],
        procedures: [],
        exports: [],
      },
      dependencies: {
        internal: [],
        external: [{ name: 'hono', version: '^4.0.0', dev: false }],
      },
    });

    const results = benchmarkAgainstBestPractices([manifest]);
    const cors = results.find(r => r.practice === 'CORS configuration');
    // Hono provides CORS built-in — should not be 'missing'
    expect(cors?.status).not.toBe('missing');
  });

  it('marks security headers as present for Hono projects (secureHeaders() built-in)', () => {
    const manifest = makeManifest({
      repoId: 'hono-backend',
      apiSurface: {
        routes: [{ method: 'GET', path: '/api/items', handler: 'getItems', file: 'src/index.ts', line: 5 }],
        procedures: [],
        exports: [],
      },
      dependencies: {
        internal: [],
        external: [{ name: 'hono', version: '^4.0.0', dev: false }],
      },
    });

    const results = benchmarkAgainstBestPractices([manifest]);
    const helmet = results.find(r => r.practice === 'Security headers (Helmet)');
    expect(helmet?.status).not.toBe('missing');
  });

  it('skips server-only checks for repos with no routes and no procedures', () => {
    // An iOS app or pure-UI repo: no routes, no procedures
    const manifest = makeManifest({
      repoId: 'ios-app',
      language: 'swift',
      apiSurface: { routes: [], procedures: [], exports: [] },
      dependencies: { internal: [], external: [] },
    });

    const results = benchmarkAgainstBestPractices([manifest]);
    // CORS, rate limiting, security headers should all return null (skipped)
    const cors = results.find(r => r.practice === 'CORS configuration');
    const rateLimiting = results.find(r => r.practice === 'Rate limiting');
    const headers = results.find(r => r.practice === 'Security headers (Helmet)');

    expect(cors).toBeUndefined();
    expect(rateLimiting).toBeUndefined();
    expect(headers).toBeUndefined();
  });
});
```

### Step 2: Run to verify failure

```bash
npm test tests/evolution/competitive-benchmarker.test.ts 2>&1 | grep -E "FAIL|Expected"
# Expected: FAIL — Hono CORS marked 'missing', iOS checks not skipped
```

### Step 3: Implement in `engine/evolution/competitive-benchmarker.ts`

**A. Add a Hono detection helper** near the top of the file, after the existing `const RATE_LIMIT_KEYWORDS`:

```typescript
// ─── Framework Detection ─────────────────────────────────────────────────────

/**
 * Returns true if the manifest uses Hono as its HTTP framework.
 * Hono bundles CORS and security headers — they are not separate packages.
 */
function isHonoProject(manifest: RepoManifest): boolean {
  return manifest.dependencies.external.some(d => d.name.toLowerCase() === 'hono');
}

/**
 * Returns true if this repo is a pure consumer (no server routes, no server procedures).
 * iOS apps, frontend SPAs, and CLI tools fall into this category.
 * Server-specific checks (CORS, rate limiting, security headers) should be skipped.
 */
function isNonServerRepo(manifest: RepoManifest): boolean {
  return manifest.apiSurface.routes.length === 0 && manifest.apiSurface.procedures.length === 0;
}
```

**B. Update `checkCors()`** — change:
```typescript
function checkCors(manifest: RepoManifest): BenchmarkResult | null {
  if (manifest.apiSurface.routes.length === 0) return null;
```
to:
```typescript
function checkCors(manifest: RepoManifest): BenchmarkResult | null {
  if (isNonServerRepo(manifest)) return null;
  if (manifest.apiSurface.routes.length === 0) return null;

  // Hono provides cors() built-in via hono/cors (part of the hono package).
  // Users import { cors } from 'hono/cors' — no separate cors package needed.
  if (isHonoProject(manifest)) {
    return {
      practice: 'CORS configuration',
      status: 'present',
      repo: manifest.repoId,
      category: 'security',
      suggestion: 'CORS configuration is available via hono/cors middleware.',
    };
  }
```

Leave the rest of the function unchanged (hasPkg/hasPattern checks + return statement).

**C. Update `checkSecurityHeaders()`** — change:
```typescript
function checkSecurityHeaders(manifest: RepoManifest): BenchmarkResult | null {
  if (manifest.apiSurface.routes.length === 0) return null;
```
to:
```typescript
function checkSecurityHeaders(manifest: RepoManifest): BenchmarkResult | null {
  if (isNonServerRepo(manifest)) return null;
  if (manifest.apiSurface.routes.length === 0) return null;

  // Hono provides secureHeaders() built-in — no separate helmet package needed.
  if (isHonoProject(manifest)) {
    return {
      practice: 'Security headers (Helmet)',
      status: 'present',
      repo: manifest.repoId,
      category: 'security',
      suggestion: 'Security headers are available via Hono\'s built-in secureHeaders() middleware.',
    };
  }
```

**D. Update `checkRateLimiting()`** — add at start:
```typescript
  if (isNonServerRepo(manifest)) return null;
```

Also add `@hono/rate-limiter` and `hono-rate-limiter` to `RATE_LIMIT_KEYWORDS`:
```typescript
const RATE_LIMIT_KEYWORDS = ['rate-limit', 'ratelimit', 'rate_limit', 'throttle', 'limiter', 'bottleneck', '@hono/rate-limiter', 'hono-rate-limiter'];
```

**E. Update `checkErrorHandlingMiddleware()`** — add at start:
```typescript
  if (isNonServerRepo(manifest)) return null;
```

**F. Update `checkRequestValidation()`** — add at start:
```typescript
  if (isNonServerRepo(manifest)) return null;
```

**G. Update `checkLogging()`** — add at start:
```typescript
  if (isNonServerRepo(manifest)) return null;
```

**H. Update `checkHealthEndpoint()`** — add at start:
```typescript
  if (isNonServerRepo(manifest)) return null;
```

### Step 4: Run tests to verify pass

```bash
npm test tests/evolution/competitive-benchmarker.test.ts 2>&1 | tail -10
# Expected: all tests pass including 3 new framework-awareness tests
npm test 2>&1 | tail -5
# Expected: all tests pass
```

### Step 5: Commit

```bash
git add engine/evolution/competitive-benchmarker.ts tests/evolution/competitive-benchmarker.test.ts
git commit -m "feat(benchmarks): Hono framework awareness + non-server repo guards

Hono projects: CORS and Security headers marked 'present' since Hono bundles
cors() and secureHeaders() middleware — no separate packages needed.
Non-server repos (no routes, no procedures): all server-specific checks
(CORS, rate limiting, security headers, error middleware, logging, health
endpoint, request validation) are now skipped to eliminate iOS/frontend noise."
```

---

## Task 5: Commit Outstanding Plan Doc

**Goal:** The 69.6KB anti-hallucination plan is untracked. Get it into git.

```bash
git status docs/plans/
# Expected: shows 2026-02-27-omni-link-max-tier-anti-hallucination.md as untracked

git add docs/plans/2026-02-27-omni-link-max-tier-anti-hallucination.md
git commit -m "docs: commit max-tier anti-hallucination implementation plan"
```

---

## Final Verification

```bash
npm test 2>&1 | tail -8
# Expected:
# Test Files  30 passed (30)
# Tests  ~360+ passed
# (exact count: 348 baseline + 3 cache + 5 call-site/bridge + 1 dedup + 3 framework = 360)

npm run build 2>&1 | tail -3
# Expected: no TypeScript errors, dist/ rebuilt

# E2E smoke test against HustleXP repos:
node dist/cli.js scan --config ~/.claude/omni-link.json 2>&1 | node -e "
  let d=''; process.stdin.on('data',c=>d+=c); process.stdin.on('end',()=>{
    const j=JSON.parse(d);
    console.log('bridges:', j.contractStatus.total);
    console.log('evo:', j.evolutionOpportunities.length);
    console.log('repos:', j.repos.map(r=>r.name+':'+r.uncommittedCount));
  });
"
# Expected: bridges > 0, evo = 5, repos show correct counts
```

If bridges is still 0 after Task 2: the iOS app likely uses `URLSession` with a base URL variable + string interpolation like `"\(baseURL)/api/users"`. The regex won't match template strings (no leading `/`). In that case, note the pattern and the regex can be relaxed — but do not mark as a test failure.

---

## Summary

| Task | Files Changed | New Tests | Key Outcome |
|------|--------------|-----------|-------------|
| 1: Cache | scanner/index.ts, engine/index.ts | +3 | Warm scan <100ms |
| 2: Bridges | api-extractor.ts, scanner/index.ts | +5 | iOS→backend bridges detected |
| 3: Dedup | upgrade-proposer.ts | +1 | 1 merged suggestion vs N duplicates |
| 4: Hono | competitive-benchmarker.ts | +3 | No false CORS/helmet alerts |
| 5: Doc | docs/plans/ | 0 | Plan committed |

Total new tests: ~12. All existing 348 must continue to pass.
